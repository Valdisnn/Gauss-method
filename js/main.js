document.addEventListener('DOMContentLoaded', () => {

    'use strict';

    // Возвращает обратную матрицу `M`.
    const invertMatrix = (M) => {
        // (1) «увеличиваем» матрицу (слева) на единицу (справа)
        // (2) Повернуть матрицу слева в единицу измерения с помощью ряда элементов
        // (3) Матрица справа является обратной (была единичная матрица)
        // Есть 3 операции с первичными строками: (я комбинирую b и c в моем коде)
        // (a) Поменять местами 2 строки
        // (b) Умножаем строку на скаляр
        // (c) Добавить 2 строки

        // если матрица не квадратная: выход (ошибка)
        if (M.length !== M[0].length) {
            return;
        }

        // создаем матрицу идентичности (I) и копию (C) оригинала
        let i = 0,
            ii = 0,
            j = 0,
            dim = M.length,
            e = 0,
            t = 0;
        let I = [],
            C = [];
        for (i = 0; i < dim; i += 1) {
            // Создать строку
            I[I.length] = [];
            C[C.length] = [];
            for (j = 0; j < dim; j += 1) {

                // если мы на диагонали, ставим 1 (для идентичности)
                if (i == j) {
                    I[i][j] = 1;
                } else {
                    I[i][j] = 0;
                }

                // Также сделаем копию оригинала
                C[i][j] = M[i][j];
            }
        }

        // Выполнение операций с элементарными строками
        for (i = 0; i < dim; i += 1) {
            // получаем элемент e по диагонали
            e = C[i][i];

            // если у нас 0 на диагонали (нам нужно поменять местами нижнюю строку)
            if (e == 0) {
                // просматриваем каждую строку под i строкой
                for (ii = i + 1; ii < dim; ii += 1) {
                    // если вторая строка имеет не 0 в i вызове
                    if (C[ii][i] != 0) {
                        // это сделало бы диагональ не-0, поэтому поменяйте местами
                        for (j = 0; j < dim; j++) {
                            e = C[i][j]; // не временная строка
                            C[i][j] = C[ii][j]; // заменить i-ю строку на 2-ю
                            C[ii][j] = e; // заменить на временную
                            e = I[i][j]; // временный элемент в i-й строке
                            I[i][j] = I[ii][j]; // заменить i-ю строку на 2-ю
                            I[ii][j] = e; // заменить на временную
                        }
                        // не надо проверять другие строки, так как мы поменялись местами
                        break;
                    }
                }
                // получить новую диагональ
                e = C[i][i];
                // если все еще 0, не обратимо (ошибка)
                if (e == 0) {
                    return;
                }
            }

            // Уменьшаем эту строку на e (чтобы у нас была 1 по диагонали)
            for (j = 0; j < dim; j++) {
                C[i][j] = C[i][j] / e; // применить к исходной матрице
                I[i][j] = I[i][j] / e; // применить к будующей 
            }

            // Вычитаем эту строку (масштабируется соответствующим образом для каждой строки) из ВСЕХ
            // другие строки, так что в этом столбце будут 0
            // строки выше и ниже этой
            for (ii = 0; ii < dim; ii++) {
                // Применяем только к другим строкам (мы хотим 1 по диагонали)
                if (ii == i) {
                    continue;
                }

                // Мы хотим изменить этот элемент на 0
                e = C[ii][i];

                // Вычитаем (строка выше (или ниже), масштабированная на е) из (
                // текущая строка), но начинаем с i-го столбца и принимаем все
                // материал слева от диагонали равен 0 (что должно быть, если мы сделали это
                // алгоритм корректный)
                for (j = 0; j < dim; j++) {
                    C[ii][j] -= e * C[i][j]; // применить к исходной матрице
                    I[ii][j] -= e * I[i][j]; // применить к будующей 
                }
            }
        }

        // мы сделали все операции, C должен быть идентификатором
        // матрица I должна быть обратной:
        return I;
    };

    const parseMatrix = (text) => {
        // нормализуем ввод, чтобы вещи разделялись 1 пробелом и 1 новой строкой
        text = text.replace(/\r|\n/g, '\n').replace(/\n+/g, '\n');
        text = text.replace(/,|;|\||\t| /g, ' ').replace(/ /g, ' ');

        let textRows = text.split('\n');
        let M = [];
        let i, il = textRows.length;
        let j, jl, cols;
        for (i = 0; i < il; i += 1) {
            M.push([]);
            cols = textRows[i].split(' ');
            jl = cols.length;
            for (j = 0; j < jl; j += 1) {
                M[i].push(parseFloat(cols[j]));
            }
        }

        return M;
    };

    const printMatrix = (M) => {
        if (!M) {
            return 'Ошибочка =(';
        }
        let nRows = M.length;
        let i;
        let text = '';
        for (i = 0; i < nRows; i += 1) {
            text += '<tr><td>' + M[i].join('</td><td>') + '</td></tr>\n';
        }
        return text;
    };

    const main = () => {
        let M = parseMatrix(document.getElementById('input-matrix').value);
        let I = invertMatrix(M);
        document.getElementById('output').innerHTML = printMatrix(I);
    };

    document.getElementById('btn-compute').onclick = main;
    main();
});